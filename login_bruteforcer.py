from cgitb import text
import os
import json
import requests as r
import re
import time
from threading import Thread
from concurrent.futures import ThreadPoolExecutor, thread, ProcessPoolExecutor
from tkinter import messagebox
from tkinter import filedialog as fd
from tkinter import BOTH, E, EW, W, Toplevel, ttk
from tkinter import messagebox
from tkinter.messagebox import showerror
class Bruteforce:

    def __init__(self, user, password, url, user_payload, password_payload, label_output, textbox):
        self.user = user
        self.password = password
        self.url = url
        self.user_payload = user_payload
        self.password_payload = password_payload

        self.thread_alive = True

        self.textbox = textbox
        self.label_output = label_output
        self.valid_urls_list = list()


        url = url.strip()
        if not re.match("^http://", self.url) and not re.match("^https://", self.url):
            self.url = "http://" + self.url
        if r.post(self.url, data = {self.user_payload:"Test", self.password_payload:"Test"}).status_code == 404:
            print("TEST")
            messagebox.showerror(title="Payload Error", message="Response to POST is incorrect status code")
            self.thread_alive = False
            return
        else:
            print("Test")
            self.thread_starter()

    def thread_starter(self):
        print("Test 2")
        print(self.user)
        print(self.password)
        # Start thread depending on type of list
        if os.path.exists(self.user) and os.path.exists(self.password):
            print("Both are files")
        #        self.thread = Thread(target=self.discoverer_controller)
        #        self.thread.start()

        if os.path.exists(self.user) and not os.path.exists(self.password):
            print("Enumerating Users")
            self.thread = Thread(target=self.bruteforcer_users_controller)
            self.thread.start()
            return

        if os.path.exists(self.password) and not os.path.exists(self.user):
            print("Enumerating Passwords")
        else:
            print("1 pass, 1 user")  

    def thread_controller(self):
        if self.thread.is_alive():
            self.pool.shutdown(wait=False, cancel_futures=True)
            # NEED TO LOOP THROUGH JSON TO CHECK IF URL IS ALREADY KNOWN + APPEND INSTEAD OF OVERWRITING
            with open(f"Targets/{self.url}/valid_combinations.json", "w") as f:
                json.dump(self.valid_urls_list, f)


    def bruteforcer_users_worker(self, username):
        username = username.strip()
        payload = {self.user_payload:username, self.password_payload:self.password}
        self.label_output.set(payload)
        req = r.post(self.url, data=payload, allow_redirects=False)
        print(req.status_code)
        if req.status_code == 302:
            print("TESTING")
            self.textbox.insert("end", payload + "\n")
            self.valid_urls_list.append(username)
            print("Test")

    def bruteforcer_users_controller(self):
        user_list = []
        start_time = time.time()
        with open(self.user) as wordlist:
            for line in wordlist:
                user_list.append(line.strip())
        try:
            with ThreadPoolExecutor() as self.pool:
                self.pool.map(self.bruteforcer_users_worker,user_list)
        except Exception:
            pass
        end_time = time.time()
        print("Time taken", end_time - start_time)
        return



    def bruteforcer_passwords(self):
        print("Test 5")
        # Enumerate Passwords

    def bruteforcer_passwords_worker(self):
        return

    def bruteforcer_passwords_controller(self):
        return



    def bruteforcer_combined(self):
        print("Test 6")
        # Enumerate Both 

    def bruteforcer_combined_worker(self):
        return

    def bruteforcer_combined_controller(self):
        return

 


    

